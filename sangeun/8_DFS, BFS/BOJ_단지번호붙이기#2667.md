# [BOJ] 단지번호붙이기#2667 / 실버1 / 250808 / 50분 (힌트 확인)

[백준/단지번호붙이기#2667](https://www.acmicpc.net/problem/2667)

### 문제 설명

> 지도에서 연결되어 있는 아파트들을 단지로 묶어, 지도에 존재하는 단지들의 총 개수와 각 단지에 포함되는 아파트들의 개수를 오름차순으로 정렬하여 출력하는 프로그램

### 해결 방법

1. 상하좌우로 탐색하여 연결되어 있는 데이터를 찾기
2. 그러나, 단지이기에 중복 탐색을 하지 않도록 새 좌표를 방문하지 않은 곳이고, 좌표의 데이터가 1이라면 탐색을 수행하도록 한다.
3. 탐색이 완료되었을 때, 단지 개수 결과를 리스트로 저장한다.
4. 이후 속도를 위해, 반복적으로 println을 하는 것이 아닌, StringBuilder를 통해 한 번에 출력을 수행

### 후기

그래도 몇 번 구현해봤다고 구현이 자연스러워졌다.
어떤 방식으로 해야 할 지에 대해서도 좀 감이 잡히는 느낌이다.
주석을 상세하게 다는 것이 도움이 되는 듯 하다

## 코드

```java
public class SetAddrNum2667 {

  // 지도 크기
  static int N;
  // 그래프/방문 여부
  static char[][] map;
  static boolean[][] visited;

  // 단지 개수 계산용 데이터
  static int count = 0;
  // 결과값 저장할 리스트
  static List<Integer> result = new ArrayList<>();

  // 상하좌우
  static int[] dx = {0, 0, 1, -1};
  static int[] dy = {1, -1, 0, 0};

  static void search(int x, int y) {
    visited[x][y] = true;
    count++;

    // 상하좌우 반복하며 탐색
    for (int dir = 0; dir < 4; dir++) {
      // 새로 탐색할 위치 설정 (x, y 좌표)
      int newX = x + dx[dir];
      int newY = y + dy[dir];

      // 탐색할 위치 좌표가 지도의 크기를 벗어나면 그냥 넘어감
      if (newX < 0 || newX >= N || newY < 0 || newY >= N) {
        continue;
      }

      // 새 좌표를 방문하지 않았고, 그 좌표의 데이터가 '1' 이라면 탐색 수행
      if (!visited[newX][newY] && map[newX][newY] == '1') {
        search(newX, newY);
      }
    }

  }

  public void solution() throws IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    StringBuilder sb = new StringBuilder();
    N = Integer.parseInt(br.readLine());

    // 그래프, 방문 여부 데이터 할당
    map = new char[N][N];
    visited = new boolean[N][N];

    // 그래프에 입력된 데이터 넣기
    for (int i = 0; i < N; i++) {
      char[] array = br.readLine().toCharArray();
      for (int j = 0; j < N; j++) {
        map[i][j] = array[j]; // 0이나 1
      }
    }

    // 탐색 시작
    for (int i = 0; i < N; i++) {
      for (int j = 0; j < N; j++) {
        // 새로운 단지 탐색
        // 방문하지 않은 곳 + 그래프 값이 1인 곳을 방문하여 탐색 시작
        if (!visited[i][j] && map[i][j] == '1') {
          search(i, j);
          result.add(count);  // 탐색 후 단지 개수 결과 리스트에 저장
          count = 0;  // 단지 개수 데이터 초기화
        }
      }
    }

    result.sort(null);  // 결과 오름차순 정렬
    sb.append(result.size()).append("\n");  // 총 개수 출력용 빌더에 추가
    result.forEach(rst -> sb.append(rst).append("\n")); // 단지 개수 출력용 빌더에 반복하여 추가

    System.out.println(sb);
  }

}

```
