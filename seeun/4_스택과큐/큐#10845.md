# 큐#10845 / 실버 4
[백준 #10845] (https://www.acmicpc.net/problem/10845)

## 문제 설명

> 정수를 저장하는 큐를 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오

## 해결 방법

문제에서 명령을 정해주고 있다. 해당 명령들을 그대로 구현하면 된다.

### 명령

push X: 정수 X를 큐에 넣는 연산이다. <br>
pop: 큐에서 가장 앞에 있는 정수를 빼고, 그 수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.<br>
size: 큐에 들어있는 정수의 개수를 출력한다.<br>
empty: 큐가 비어있으면 1, 아니면 0을 출력한다.<br>
front: 큐의 가장 앞에 있는 정수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.<br>
back: 큐의 가장 뒤에 있는 정수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.

### 문제 풀이 방식

if와 elif를 이용해 커맨드에 따라 필요 동작을 수행하도록 했다.<br>
대부분의 명령어들은 명령어 하나만 입력하면 됐지만 push는 뒤에 숫자가 붙어야했다.<br>
그래서 입력받은 명령어는 split()을 통해 배열로 command에 저장하는 방식을 사용했다. <br>

어려웠던건 계속 시간초과가 발생한다는 점이었다.<br>
이걸 해결하기 위해<br>
1. dequeue()사용
처음 pop()을 구현할 때는 단순히 큐의 가장 마지막에 있는 값을 반환하는 방식을 사용했다.<br>
그런데 이 방식은 큐의 길이가 N이라고 하면 첫 번째 원소를 제거한 다음 나머지 모든 원소들을 한 칸 씩 옮겨야 하기 때문에 O(N-1)의 시간이 걸린다고 한다.<br>

deque()는 이중 연결 리스트 기반이다.<br>
그래서 deque에서 popleft()를 사용하면 단순히 첫 번째 노드의 링크만 변경하면 되기 때문에 원소 개수와 상관없이 O(1)의 시간이 걸린다.<br>
따라서 시간절약 가능!

2. 입력 방식 변경
입력 방식을 input() 방식에서 sys.stdin.readline 방식으로 변경했다.<br>
input()은 내부적으로 여러 단계의 처리 과정을 거치지만 후자는 최소한의 처리만 수행한다.<br>
그래서 대량의 입력이 있는 경우엔 후자를 많이 택한다고 한다.

# 코드
import sys
from collections import deque

input = sys.stdin.readline
write = sys.stdout.write

count = int(input())
queue = deque()
results = []

for _ in range(count):
    command = input().split()
    
    if command[0] == 'push':
        queue.append(int(command[1]))
    elif command[0] == 'pop':
        results.append(str(queue.popleft() if queue else -1))
    elif command[0] == 'size':
        results.append(str(len(queue)))
    elif command[0] == 'empty':
        results.append(str(1 if not queue else 0))
    elif command[0] == 'front':
        results.append(str(queue[0] if queue else -1))
    elif command[0] == 'back':
        results.append(str(queue[-1] if queue else -1))

write('\n'.join(results) + '\n')